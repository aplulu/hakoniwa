package handler

import (
	"context"
	"errors"

	"github.com/aplulu/hakoniwa/internal/api/hakoniwa"
	"github.com/aplulu/hakoniwa/internal/config"
	"github.com/aplulu/hakoniwa/internal/domain/model"
	"github.com/aplulu/hakoniwa/internal/interface/http/middleware"
	"github.com/aplulu/hakoniwa/internal/usecase"
)

type APIHandler struct {
	authUsecase     usecase.Auth
	instanceUsecase usecase.InstanceManagement
}

func NewAPIHandler(auth usecase.Auth, instance usecase.InstanceManagement) *APIHandler {
	return &APIHandler{
		authUsecase:     auth,
		instanceUsecase: instance,
	}
}

// GetAuthMe implements getAuthMe operation.
// GET /auth/me
func (h *APIHandler) GetAuthMe(ctx context.Context) (hakoniwa.GetAuthMeRes, error) {
	user, ok := middleware.GetUserFromContext(ctx)
	if !ok {
		return &hakoniwa.GetAuthMeUnauthorized{}, nil
	}

	// Get instance status
	instance, err := h.instanceUsecase.GetInstanceStatus(ctx, user.ID)
	if err != nil {
		// If instance not found or error, we might still return user info with empty instance?
		// For now, assume error means no instance or internal error.
		// If it's a "not found" error, we should return user with no instance.
		// But since usecase just returns error, let's just return user only for now if possible,
		// or return internal error if critical.
		// Assuming error might be "not found", we can proceed.
		// However, the generated code expects OptInstance.
		// Let's log error and return user with empty instance for now if we can't distinguish.
		// Real implementation should handle "NotFound" properly.
	}

	res := &hakoniwa.AuthStatus{
		User: hakoniwa.User{
			ID:   user.ID,
			Type: hakoniwa.UserType(user.Type),
		},
	}

	if instance != nil {
		res.Instance = hakoniwa.NewOptInstance(hakoniwa.Instance{
			Status: hakoniwa.InstanceStatus(instance.Status),
			PodIP:  hakoniwa.NewOptString(instance.PodIP),
		})
	}

	return res, nil
}

// LoginAnonymous implements loginAnonymous operation.
// POST /auth/anonymous
func (h *APIHandler) LoginAnonymous(ctx context.Context) (*hakoniwa.AuthStatus, error) {
	token, user, err := h.authUsecase.LoginAnonymous(ctx)
	if err != nil {
		return nil, err
	}

	// Set cookie in response?
	// The API handler interface generated by ogen doesn't give direct access to ResponseWriter to set cookies easily
	// unless we use middleware or wrap the handler.
	// Actually, ogen handlers can implement http.Handler but here we are implementing the interface.
	// To set cookies, we might need to use a middleware that injects a cookie setter or use context.
	// Or, we can rely on the caller (Gateway) to handle cookie if we return the token?
	// But here we return AuthStatus.
	// Usually ogen allows setting headers via response types if defined in OpenAPI.
	// We didn't define Set-Cookie header in OpenAPI.
	// We should probably update OpenAPI to include Set-Cookie header or handle it in a wrapper.
	// For now, let's assume we need to handle cookie setting.
	// Since we cannot modify OpenAPI right now easily without breaking flow,
	// we can use a thread-local or context-based approach if supported, or wrapper.
	// Let's add a SetCookie hook in the context using middleware?
	// Or simpler: The generated Server has `ServeHTTP`. We can wrap the `LoginAnonymous` logic?
	// No, `LoginAnonymous` is called by `Server`.

	// Ideally: Define `Set-Cookie` header in OpenAPI response.
	// Workaround: Use a custom middleware that intercepts the response?
	// Or use context to pass the token to a middleware that sets the cookie?

	// Let's use a context value to pass the token back to the wrapper.
	if setter, ok := ctx.Value(CookieSetterKey).(func(string)); ok {
		setter(token)
	}

	// Start instance creation
	if err := h.instanceUsecase.CreateInstance(ctx, user.ID); err != nil {
		// If max instances reached, return error
		if errors.Is(err, model.ErrMaxInstancesReached) {
			// Ideally return 503, but for now return error
			return nil, err
		}
		return nil, err
	}

	return &hakoniwa.AuthStatus{
		User: hakoniwa.User{
			ID:   user.ID,
			Type: hakoniwa.UserType(user.Type),
		},
		// Instance is pending initially
		Instance: hakoniwa.NewOptInstance(hakoniwa.Instance{
			Status: hakoniwa.InstanceStatusPending,
		}),
	}, nil
}

// GetConfiguration implements getConfiguration operation.
// GET /configuration
func (h *APIHandler) GetConfiguration(ctx context.Context) (*hakoniwa.Configuration, error) {
	return &hakoniwa.Configuration{
		Title:             config.Title(),
		Message:           config.Message(),
		LogoURL:           config.LogoURL(),
		TermsOfServiceURL: hakoniwa.NewOptString(config.TermsOfServiceURL()),
		PrivacyPolicyURL:  hakoniwa.NewOptString(config.PrivacyPolicyURL()),
	}, nil
}

// CookieSetterKey is used to inject a callback to set cookies
type cookieSetterKey struct{}

var CookieSetterKey = cookieSetterKey{}

func WithCookieSetter(ctx context.Context, setter func(token string)) context.Context {
	return context.WithValue(ctx, CookieSetterKey, setter)
}
